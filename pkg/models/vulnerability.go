package models

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"time"

	"github.com/g-rath/osv-detector/pkg/semantic"
)

// Package identifies the affected code library or command provided by the
// package.
//
// See: https://ossf.github.io/osv-schema/#affectedpackage-field
type Package struct {
	Ecosystem Ecosystem `json:"ecosystem"`
	Name      string    `json:"name"`
	Purl      string    `json:"purl,omitempty"`
}

// Event describes a single version that either:
//
//   - Introduces a vulnerability: {"introduced": string}
//   - Fixes a vulnerability: {"fixed": string}
//   - Describes the last known affected version: {"last_affected": string}
//   - Sets an upper limit on the range being described: {"limit": string}
//
// Event instances form part of a “timeline” of status changes for the affected
// package described by the Affected struct.
//
// See: https://ossf.github.io/osv-schema/#affectedrangesevents-fields
type Event struct {
	Introduced   string `json:"introduced,omitempty"`
	Fixed        string `json:"fixed,omitempty"`
	LastAffected string `json:"last_affected,omitempty"`
	Limit        string `json:"limit,omitempty"`
}

// Range describes the affected range of given version for a specific package.
//
// See: https://ossf.github.io/osv-schema/#affectedranges-field
type Range struct {
	Type             RangeType              `json:"type"`
	Events           []Event                `json:"events"`
	Repo             string                 `json:"repo,omitempty"`
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// Severity is used to describe the severity of a vulnerability for an affected
// package using one or more quantitative scoring methods.
//
// See: https://ossf.github.io/osv-schema/#severity-field
type Severity struct {
	Type  string `json:"type"`
	Score string `json:"score"`
}

// Affected describes an affected package version, meaning one instance that
// contains the vulnerability.
//
// See: https://ossf.github.io/osv-schema/#affected-fields
type Affected struct {
	Package           Package                `json:"package,omitempty"`
	Severity          []Severity             `json:"severity,omitempty"`
	Ranges            []Range                `json:"ranges,omitempty"`
	Versions          []string               `json:"versions,omitempty"`
	DatabaseSpecific  map[string]interface{} `json:"database_specific,omitempty"`
	EcosystemSpecific map[string]interface{} `json:"ecosystem_specific,omitempty"`
}

// MarshalJSON implements the json.Marshaler interface.
//
// This method ensures Package is only present if it is not equal to the zero value.
// This is achieved by embedding the Affected struct with a pointer to Package used
// to populate the "package" key in the JSON object.
func (a Affected) MarshalJSON() ([]byte, error) {
	type rawAffected Affected // alias Affected to avoid recursion during Marshal
	type wrapper struct {
		Package *Package `json:"package,omitempty"`
		rawAffected
	}
	raw := wrapper{rawAffected: rawAffected(a)}
	if a.Package == (Package{}) {
		raw.Package = nil
	} else {
		raw.Package = &(a.Package)
	}

	return json.Marshal(raw)
}

// Reference links to additional information, advisories, issue tracker entries,
// and so on about the vulnerability itself.
//
// See: https://ossf.github.io/osv-schema/#references-field
type Reference struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}

// Credit gives credit for the discovery, confirmation, patch, or other events
// in the life cycle of a vulnerability.
//
// See: https://ossf.github.io/osv-schema/#credits-fields
type Credit struct {
	Name    string   `json:"name"`
	Type    string   `json:"type,omitempty"`
	Contact []string `json:"contact,omitempty"`
}

// Vulnerability is the core Open Source Vulnerability (OSV) data type.
//
// The full documentation for the schema is available at
// https://ossf.github.io/osv-schema.
type Vulnerability struct {
	SchemaVersion    string                 `json:"schema_version,omitempty"`
	ID               string                 `json:"id"`
	Modified         time.Time              `json:"modified"`
	Published        time.Time              `json:"published,omitempty"`
	Withdrawn        time.Time              `json:"withdrawn,omitempty"`
	Aliases          []string               `json:"aliases,omitempty"`
	Related          []string               `json:"related,omitempty"`
	Summary          string                 `json:"summary,omitempty"`
	Details          string                 `json:"details,omitempty"`
	Affected         []Affected             `json:"affected,omitempty"`
	Severity         []Severity             `json:"severity,omitempty"`
	References       []Reference            `json:"references,omitempty"`
	Credits          []Credit               `json:"credits,omitempty"`
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// MarshalJSON implements the json.Marshaler interface.
//
// This method ensures times all times are formatted correctly according to the schema.
func (v Vulnerability) MarshalJSON() ([]byte, error) {
	type rawVulnerability Vulnerability // alias Vulnerability to avoid recursion during Marshal
	type wrapper struct {
		Modified  string `json:"modified"`
		Published string `json:"published,omitempty"`
		Withdrawn string `json:"withdrawn,omitempty"`
		rawVulnerability
	}
	raw := wrapper{rawVulnerability: rawVulnerability(v)}
	raw.Modified = v.Modified.UTC().Format(time.RFC3339)
	if !v.Published.IsZero() {
		raw.Published = v.Published.UTC().Format(time.RFC3339)
	}
	if !v.Withdrawn.IsZero() {
		raw.Withdrawn = v.Withdrawn.UTC().Format(time.RFC3339)
	}

	return json.Marshal(raw)
}

func (e Event) version() string {
	if e.Introduced != "" {
		return e.Introduced
	}

	if e.Fixed != "" {
		return e.Fixed
	}

	if e.Limit != "" {
		return e.Limit
	}

	if e.LastAffected != "" {
		return e.LastAffected
	}

	return ""
}

func (ar Range) containsVersion(pkg PackageInfo) bool {
	if ar.Type != RangeEcosystem && ar.Type != RangeSemVer {
		return false
	}
	// todo: we should probably warn here
	if len(ar.Events) == 0 {
		return false
	}

	vp := semantic.MustParse(pkg.Version, pkg.CompareAs)

	sort.Slice(ar.Events, func(i, j int) bool {
		return semantic.MustParse(ar.Events[i].version(), pkg.CompareAs).CompareStr(ar.Events[j].version()) < 0
	})

	var affected bool
	for _, e := range ar.Events {
		if affected {
			if e.Fixed != "" {
				affected = vp.CompareStr(e.Fixed) < 0
			} else if e.LastAffected != "" {
				affected = e.LastAffected == pkg.Version || vp.CompareStr(e.LastAffected) <= 0
			}
		} else if e.Introduced != "" {
			affected = e.Introduced == "0" || vp.CompareStr(e.Introduced) >= 0
		}
	}

	return affected
}

// affectsVersion checks if the given version is within the range
// specified by the events of any "Ecosystem" or "Semver" type ranges
func affectsVersion(a []Range, pkg PackageInfo) bool {
	for _, r := range a {
		if r.Type != RangeEcosystem && r.Type != RangeSemVer {
			return false
		}
		if r.containsVersion(pkg) {
			return true
		}
	}

	return false
}

func (v Vulnerability) isAliasOfID(id string) bool {
	for _, alias := range v.Aliases {
		if alias == id {
			return true
		}
	}

	return false
}

func (v Vulnerability) isAliasOf(vulnerability Vulnerability) bool {
	for _, alias := range vulnerability.Aliases {
		if v.ID == alias || v.isAliasOfID(alias) {
			return true
		}
	}

	return false
}

func (v Vulnerability) AffectsEcosystem(ecosystem Ecosystem) bool {
	for _, affected := range v.Affected {
		if string(affected.Package.Ecosystem) == string(ecosystem) {
			return true
		}
	}

	return false
}

func (v Vulnerability) IsAffected(pkg PackageInfo) bool {
	for _, affected := range v.Affected {
		if string(affected.Package.Ecosystem) == string(pkg.Ecosystem) &&
			affected.Package.Name == pkg.Name {
			if len(affected.Ranges) == 0 && len(affected.Versions) == 0 {
				_, _ = fmt.Fprintf(
					os.Stderr,
					"%s does not have any ranges or versions - this is probably a mistake!\n",
					v.ID,
				)

				continue
			}

			for _, version := range affected.Versions {
				if version == pkg.Version {
					return true
				}
			}

			if affectsVersion(affected.Ranges, pkg) {
				return true
			}

			if pkg.Version == "" {
				return true
			}
		}
	}

	return false
}
