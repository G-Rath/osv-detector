package models_test

import (
	"encoding/json"
	"testing"
	"time"

	"github.com/g-rath/osv-detector/pkg/lockfile"
	"github.com/g-rath/osv-detector/pkg/models"
)

func TestAffected_MarshalJSONWithPackage(t *testing.T) {
	t.Parallel()
	v := models.Vulnerability{
		ID: "TEST-0000",
		Affected: []models.Affected{
			{
				Package:  models.Package{Ecosystem: models.EcosystemPyPI, Name: "requests"},
				Versions: []string{"1.0.0"},
			},
		},
	}
	got, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("Marshal() = %v; want no error", err)
	}
	want := `{"modified":"0001-01-01T00:00:00Z","id":"TEST-0000","affected":[{"package":{"ecosystem":"PyPI","name":"requests"},"versions":["1.0.0"]}]}`
	if string(got) != want {
		t.Errorf("Marshal() = %v; want %v", string(got), want)
	}
}

func TestAffected_MarshalJSONWithoutPackage(t *testing.T) {
	t.Parallel()
	v := models.Vulnerability{
		ID: "TEST-0000",
		Affected: []models.Affected{
			{
				Versions: []string{"1.0.0"},
			},
		},
	}
	got, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("Marshal() = %v; want no error", err)
	}
	want := `{"modified":"0001-01-01T00:00:00Z","id":"TEST-0000","affected":[{"versions":["1.0.0"]}]}`
	if string(got) != want {
		t.Errorf("Marshal() = %v; want %v", string(got), want)
	}
}

func TestVulnerability_MarshalJSONTimes(t *testing.T) {
	t.Parallel()
	losAngeles, err := time.LoadLocation("America/Los_Angeles")
	if err != nil {
		panic(err)
	}

	tests := []struct {
		name string
		vuln models.Vulnerability
		want string
	}{
		{
			name: "empty",
			vuln: models.Vulnerability{
				ID: "TEST-0000",
			},
			want: `{"modified":"0001-01-01T00:00:00Z","id":"TEST-0000"}`,
		},
		{
			name: "no withdraw",
			vuln: models.Vulnerability{
				ID:        "TEST-0000",
				Modified:  time.Date(2023, 12, 1, 12, 30, 30, 0, time.UTC),
				Published: time.Date(2021, 6, 30, 1, 0, 0, 0, time.UTC),
			},
			want: `{"modified":"2023-12-01T12:30:30Z","published":"2021-06-30T01:00:00Z","id":"TEST-0000"}`,
		},
		{
			name: "all UTC",
			vuln: models.Vulnerability{
				ID:        "TEST-0000",
				Modified:  time.Date(2023, 12, 1, 12, 30, 30, 0, time.UTC),
				Published: time.Date(2021, 6, 30, 1, 0, 0, 0, time.UTC),
				Withdrawn: time.Date(2022, 1, 15, 23, 59, 59, 0, time.UTC),
			},
			want: `{"modified":"2023-12-01T12:30:30Z","published":"2021-06-30T01:00:00Z","withdrawn":"2022-01-15T23:59:59Z","id":"TEST-0000"}`,
		},
		{
			name: "all Los Angeles",
			vuln: models.Vulnerability{
				ID:        "TEST-0000",
				Modified:  time.Date(2023, 12, 1, 12, 30, 30, 0, losAngeles),
				Published: time.Date(2021, 6, 30, 1, 0, 0, 0, losAngeles),
				Withdrawn: time.Date(2022, 1, 15, 23, 59, 59, 0, losAngeles),
			},
			want: `{"modified":"2023-12-01T20:30:30Z","published":"2021-06-30T08:00:00Z","withdrawn":"2022-01-16T07:59:59Z","id":"TEST-0000"}`,
		},
	}
	for _, test := range tests {
		innerTest := test
		t.Run(innerTest.name, func(t *testing.T) {
			t.Parallel()
			got, err := json.Marshal(innerTest.vuln)
			if err != nil {
				t.Fatalf("Marshal() = %v; want no error", err)
			}
			if string(got) != innerTest.want {
				t.Errorf("Marshal() = %v; want %v", string(got), innerTest.want)
			}
		})
	}
}

func expectIsAffected(t *testing.T, vuln models.Vulnerability, version string, expectAffected bool) {
	t.Helper()

	pkg := lockfile.PackageDetails{
		Name:      "my-package",
		Version:   version,
		Ecosystem: lockfile.NpmEcosystem,
		CompareAs: lockfile.NpmEcosystem,
	}

	if vuln.IsAffected(pkg) != expectAffected {
		if expectAffected {
			t.Errorf("Expected OSV to affect package version %s but it did not", version)
		} else {
			t.Errorf("Expected OSV not to affect package version %s but it did", version)
		}
	}
}

func buildOSVWithAffected(affected ...models.Affected) models.Vulnerability {
	return models.Vulnerability{
		ID:        "1",
		Published: time.Time{},
		Modified:  time.Time{},
		Details:   "This is an open source vulnerability!",
		Affected:  affected,
	}
}

func buildEcosystemAffectsRange(events ...models.Event) models.Range {
	return models.Range{Type: models.RangeEcosystem, Events: events}
}

func buildSemverAffectsRange(events ...models.Event) models.Range {
	return models.Range{Type: models.RangeSemVer, Events: events}
}

func TestOSV_AffectsEcosystem(t *testing.T) {
	t.Parallel()

	type AffectsTest struct {
		Affected  []models.Affected
		Ecosystem models.Ecosystem
		Expected  bool
	}

	tests := []AffectsTest{
		{Affected: nil, Ecosystem: "Go", Expected: false},
		{Affected: nil, Ecosystem: "npm", Expected: false},
		{Affected: nil, Ecosystem: "PyPI", Expected: false},
		{Affected: nil, Ecosystem: "", Expected: false},
		{
			Affected: []models.Affected{
				{Package: models.Package{Ecosystem: "crates.io"}},
				{Package: models.Package{Ecosystem: "npm"}},
				{Package: models.Package{Ecosystem: "PyPI"}},
			},
			Ecosystem: "Packagist",
			Expected:  false,
		},
		{
			Affected: []models.Affected{
				{Package: models.Package{Ecosystem: "NuGet"}},
			},
			Ecosystem: "NuGet",
			Expected:  true,
		},
		{
			Affected: []models.Affected{
				{Package: models.Package{Ecosystem: "npm"}},
				{Package: models.Package{Ecosystem: "npm"}},
			},
			Ecosystem: "npm",
			Expected:  true,
		},
	}

	for i, test := range tests {
		vuln := models.Vulnerability{
			ID:        "1",
			Published: time.Time{},
			Modified:  time.Time{},
			Details:   "This is an open source vulnerability!",
			Affected:  test.Affected,
		}

		if vuln.AffectsEcosystem(test.Ecosystem) != test.Expected {
			t.Errorf(
				"Test #%d: Expected OSV to return %t but it returned %t",
				i,
				test.Expected,
				!test.Expected,
			)
		}
	}

	// test when the OSV doesn't have an "Affected"
	vuln := models.Vulnerability{
		ID:        "1",
		Published: time.Time{},
		Modified:  time.Time{},
		Details:   "This is an open source vulnerability!",
		Affected:  nil,
	}

	if vuln.AffectsEcosystem("npm") {
		t.Errorf(
			"Expected OSV to report 'false' when it doesn't have an Affected, but it reported true!",
		)
	}
}

func TestOSV_IsAffected_AffectsWithEcosystem_DifferentEcosystem(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemPyPI, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(models.Event{Introduced: "0"}),
			},
		},
	)

	for _, v := range []string{"1.0.0", "1.1.1", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}
}

func TestOSV_IsAffected_AffectsWithEcosystem_SingleAffected(t *testing.T) {
	t.Parallel()

	var vuln models.Vulnerability

	// "Introduced: 0" means everything is affected
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(models.Event{Introduced: "0"}),
			},
		},
	)

	for _, v := range []string{"1.0.0", "1.1.1", "2.0.0"} {
		expectIsAffected(t, vuln, v, true)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)

	// "Fixed: 1" means all versions after this are not vulnerable
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)

	// multiple fixes and introduced
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "3.2.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)

	// "LastAffected: 1" means all versions after this are not vulnerable
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{LastAffected: "1"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc", "1.0.0"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.1", "1.1.0", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)

	// mix of fixes, last_known_affected, and introduced
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
					models.Event{Introduced: "2.1.0"},
					models.Event{LastAffected: "3.1.9"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc", "3.1.9"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_AffectsWithEcosystem_MultipleAffected(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
				),
			},
		},
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "3.2.0"},
				),
			},
		},
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "3.3.0"},
					models.Event{LastAffected: "3.5.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"3.3.1", "3.4.5"} {
		expectIsAffected(t, vuln, v, true)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_AffectsWithEcosystem_Unsorted(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildEcosystemAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "1"},
					models.Event{LastAffected: "3.1.9"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc", "3.1.9"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_AffectsWithSemver_DifferentEcosystem(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemPyPI, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(models.Event{Introduced: "0"}),
			},
		},
	)

	for _, v := range []string{"1.0.0", "1.1.1", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}
}

func TestOSV_IsAffected_AffectsWithSemver_SingleAffected(t *testing.T) {
	t.Parallel()

	var vuln models.Vulnerability

	// "Introduced: 0" means everything is affected
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(models.Event{Introduced: "0"}),
			},
		},
	)

	for _, v := range []string{"v1.0.0", "v1.1.1", "v2.0.0"} {
		expectIsAffected(t, vuln, v, true)
	}

	// "Fixed: 1" means all versions after this are not vulnerable
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1.0.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// multiple fixes and introduced
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "3.2.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)

	// "LastAffected: 1" means all versions after this are not vulnerable
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{LastAffected: "1.0.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc", "1.0.0"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.1", "1.1.0", "2.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// mix of fixes, last_known_affected, and introduced
	vuln = buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
					models.Event{Introduced: "2.1.0"},
					models.Event{LastAffected: "3.1.9"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_AffectsWithSemver_MultipleAffected(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Fixed: "1"},
				),
			},
		},
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "3.2.0"},
				),
			},
		},
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "3.3.0"},
					models.Event{LastAffected: "3.5.0"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"3.3.1", "3.4.5", "3.5.0"} {
		expectIsAffected(t, vuln, v, true)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_AffectsWithSemver_Unsorted(t *testing.T) {
	t.Parallel()

	// mix of fixes, last_known_affected, and introduced
	vuln := buildOSVWithAffected(
		models.Affected{
			Package: models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Ranges: []models.Range{
				buildSemverAffectsRange(
					models.Event{Introduced: "0"},
					models.Event{Introduced: "2.1.0"},
					models.Event{Fixed: "1"},
					models.Event{LastAffected: "3.1.9"},
				),
			},
		},
	)

	for _, v := range []string{"0.0.0", "0.1.0", "0.0.0.1", "1.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"1.0.0", "1.1.0", "2.0.0rc2", "2.0.1"} {
		expectIsAffected(t, vuln, v, false)
	}

	for _, v := range []string{"2.1.1", "2.3.4", "3.0.0", "3.0.0-rc"} {
		expectIsAffected(t, vuln, v, true)
	}

	for _, v := range []string{"3.2.0", "3.2.1", "4.0.0"} {
		expectIsAffected(t, vuln, v, false)
	}

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}

func TestOSV_IsAffected_OnlyVersions(t *testing.T) {
	t.Parallel()

	vuln := buildOSVWithAffected(
		models.Affected{
			Package:  models.Package{Ecosystem: models.EcosystemNPM, Name: "my-package"},
			Versions: []string{"1.0.0"},
		},
	)

	expectIsAffected(t, vuln, "0.0.0", false)
	expectIsAffected(t, vuln, "1.0.0", true)
	expectIsAffected(t, vuln, "1.0.0-beta1", false)
	expectIsAffected(t, vuln, "1.1.0", false)

	// an empty version should always be treated as affected
	expectIsAffected(t, vuln, "", true)
}
