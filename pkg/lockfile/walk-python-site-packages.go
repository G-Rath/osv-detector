package lockfile

import (
	"bufio"
	"fmt"
	"github.com/anchore/stereoscope/pkg/file"
	"github.com/anchore/stereoscope/pkg/filetree"
	"github.com/anchore/stereoscope/pkg/filetree/filenode"
	"github.com/anchore/stereoscope/pkg/image"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func readPythonSitePackageMetadata(r io.Reader) (name, version string, err error) {
	scanner := bufio.NewScanner(r)

	for scanner.Scan() {
		line := scanner.Text()

		if strings.HasPrefix(line, "Name: ") {
			if name != "" {
				return name, version, fmt.Errorf("multiple name fields found")
			}

			name = strings.TrimPrefix(line, "Name: ")
		}

		if strings.HasPrefix(line, "Version: ") {
			if version != "" {
				return name, version, fmt.Errorf("multiple version fields found")
			}

			version = strings.TrimPrefix(line, "Version: ")
		}
	}

	if err := scanner.Err(); err != nil {
		return name, version, err
	}

	if name == "" {
		err = fmt.Errorf("failed to find package name")
	}

	if version == "" {
		err = fmt.Errorf("failed to find package version")
	}

	return name, version, err
}

func WalkPythonSitePackagesInImage(img image.Image, pathToPythonSitePackages string) (Lockfile, error) {
	var packages []PackageDetails

	err := img.SquashedTree().Walk(
		func(path file.Path, f filenode.FileNode) error {
			metadataFile := ""

			if strings.HasSuffix(string(path), ".dist-info") {
				metadataFile = "METADATA"
			}

			if strings.HasSuffix(string(path), ".egg-info") {
				metadataFile = "PKG-INFO"
			}

			if metadataFile != "" {
				r, err := img.OpenPathFromSquash(path + file.Path("/"+metadataFile))

				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "%v\n", err)

					return nil
				}

				name, version, err := readPythonSitePackageMetadata(r)

				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "%v\n", err)

					return nil
				}

				packages = append(packages, PackageDetails{
					Name:      name,
					Version:   version,
					Commit:    "",
					Ecosystem: PipEcosystem,
					CompareAs: PipEcosystem,
				})

				return nil
			}

			return nil
		},
		&filetree.WalkConditions{
			ShouldVisit: func(path file.Path, node filenode.FileNode) bool {
				// we only want to visit the node if:
				//   1. it is a directory
				//   2. it is within the given site-packages directory
				return node.FileType == file.TypeDirectory &&
					strings.HasPrefix(string(path), pathToPythonSitePackages)
			},
			ShouldContinueBranch: func(path file.Path, node filenode.FileNode) bool {
				// We want to avoid any symlinks as they could be cyclical, and they should
				// be safe to skip since we should end up walking their targets eventually
				if IsSymlink(path, node) {
					return false
				}

				// we don't actually need to explore these directories, as site-packages is a flat module tree,
				// and we can access the metadata file within the directory when we visit it
				return !strings.HasSuffix(string(path), ".dist-info") && !strings.HasSuffix(string(path), ".egg-info")
			},
		},
	)

	sort.Slice(packages, func(i, j int) bool {
		if packages[i].Name == packages[j].Name {
			return packages[i].Version < packages[j].Version
		}

		return packages[i].Name < packages[j].Name
	})

	return Lockfile{
		FilePath: pathToPythonSitePackages,
		ParsedAs: "site-packages",
		Packages: packages,
	}, err
}

func WalkPythonSitePackages(pathToPythonSitePackages string) (Lockfile, error) {
	var packages []PackageDetails

	err := filepath.Walk(pathToPythonSitePackages, func(path string, info fs.FileInfo, err error) error {
		if info == nil {
			return err
		}

		if info.IsDir() {
			metadataFile := ""

			if strings.HasSuffix(info.Name(), ".dist-info") {
				metadataFile = "METADATA"
			}

			if strings.HasSuffix(info.Name(), ".egg-info") {
				metadataFile = "PKG-INFO"
			}

			if metadataFile != "" {
				f, err := os.Open(filepath.Join(path, metadataFile))
				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "%v\n", err)

					return nil
				}

				name, version, err := readPythonSitePackageMetadata(f)

				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "%v\n", err)

					return nil
				}

				packages = append(packages, PackageDetails{
					Name:      name,
					Version:   version,
					Commit:    "",
					Ecosystem: PipEcosystem,
					CompareAs: PipEcosystem,
				})

				return fs.SkipDir
			}
		}

		return nil
	})

	sort.Slice(packages, func(i, j int) bool {
		if packages[i].Name == packages[j].Name {
			return packages[i].Version < packages[j].Version
		}

		return packages[i].Name < packages[j].Name
	})

	return Lockfile{
		FilePath: pathToPythonSitePackages,
		ParsedAs: "site-packages",
		Packages: packages,
	}, err
}
